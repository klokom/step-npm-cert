#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

############################################
# Hardcoded defaults
############################################
CA_URL="https://ca.lab:9000"
PROV_PW_FILE="/root/.step/secrets/password"
CERTDIR="/data/nginx/certificates"
NPM_SERVICE="npm.service"
DEFAULT_RENEW_DAYS=30
LOCKFILE="/tmp/issue-cert.lock"

# New toggle: whether to pass --not-after to step ca token
ENABLE_NOT_AFTER="false"
NOT_AFTER="8760h"   # Only used if ENABLE_NOT_AFTER=true

############################################
# Load overrides
############################################
[[ -f /etc/step-npm-cert.conf ]] && source /etc/step-npm-cert.conf

# Ensure sane defaults
RELOAD_NPM="${AUTO_RELOAD_NPM:-0}"
RENEW_DAYS="${RENEW_DAYS:-$DEFAULT_RENEW_DAYS}"
COLOR="${COLOR:-auto}"
QUIET="${QUIET:-false}"
ENABLE_NOT_AFTER="${ENABLE_NOT_AFTER:-false}"
NOT_AFTER="${NOT_AFTER:-8760h}"

############################################
# Color / logging
############################################
if [[ "$COLOR" == "true" ]] || { [[ "$COLOR" == "auto" ]] && [[ -t 1 ]]; }; then
  C_RESET=$'\033[0m' C_RED=$'\033[31m' C_GREEN=$'\033[32m' \
  C_YELLOW=$'\033[33m' C_CYAN=$'\033[36m' C_BOLD=$'\033[1m'
else
  C_RESET="" C_RED="" C_GREEN="" C_YELLOW="" C_CYAN="" C_BOLD=""
fi

if [[ "$QUIET" == "true" ]]; then
  log_info() { :; }
  log_ok()   { :; }
  log_warn() { :; }
else
  log_info() { echo "${C_CYAN}[*]${C_RESET} $*"; }
  log_ok()   { echo "${C_GREEN}[+]${C_RESET} $*"; }
  log_warn() { echo "${C_YELLOW}[!]${C_RESET} $*"; }
fi

die() { echo "${C_RED}[X]${C_RESET} $*" >&2; exit 1; }

############################################
# Requirements
############################################
STEP="$(command -v step)" || die "step CLI missing"
OPENSSL="$(command -v openssl)" || die "openssl missing"

############################################
# Locking — prevent concurrent runs
############################################
exec 200>"$LOCKFILE"
if ! flock -n 200; then die "Another instance is running"; fi
trap 'flock -u 200; rm -f "$LOCKFILE" 2>/dev/null || true' EXIT INT TERM

############################################
# Helpers
############################################
normalize_domain() {
  local d="$1"
  d="${d#"${d%%[![:space:]]*}"}"
  d="${d%"${d##*[![:space:]]}"}"
  d="${d%.}"
  echo "${d,,}"
}

expand_host_range() {
  [[ $1 =~ ^([^[]*)\[([0-9]+)-([0-9]+)\]([^[]*)$ ]] &&
    for i in $(seq "${BASH_REMATCH[2]}" "${BASH_REMATCH[3]}"); do
      echo "${BASH_REMATCH[1]}${i}${BASH_REMATCH[4]}"
    done || echo "$1"
}

expand_ip_range() {
  [[ $1 =~ ^([0-9]+\.[0-9]+\.[0-9]+)\.([0-9]+)-([0-9]+)$ ]] &&
    for i in $(seq "${BASH_REMATCH[2]}" "${BASH_REMATCH[3]}"); do
      echo "${BASH_REMATCH[1]}.${i}"
    done || echo "$1"
}

dedupe() { sort -u; }

ensure_certdir() { mkdir -p "$CERTDIR"; }
crt_path() { echo "$CERTDIR/$1.crt"; }
key_path() { echo "$CERTDIR/$1.key"; }
csr_path() { echo "$CERTDIR/$1.csr"; }

############################################
# REST API / Service restart
############################################
restart_npm() {
  [[ "$RELOAD_NPM" -eq 0 ]] && return 0
  log_info "Restarting NPM..."
  if command -v systemctl >/dev/null && systemctl is-active --quiet "$NPM_SERVICE"; then
    systemctl restart "$NPM_SERVICE" \
      && log_ok "NPM restarted" \
      || log_warn "Restart failed"
  else
    log_warn "systemd/NPM service unavailable"
  fi
}

############################################
# SAN builder
############################################
build_san_args() {
  local values=()
  [[ -n "$DOMAIN" ]] && values+=("$DOMAIN")
  for item in "${SAN_INPUT[@]}"; do
    item="$(normalize_domain "$item")"
    [[ -z "$item" ]] && continue

    if [[ "$item" =~ ^([0-9]+\.){3}[0-9]+-[0-9]+$ ]]; then
      while read -r e; do values+=("$e"); done < <(expand_ip_range "$item")
    else
      while read -r e; do values+=("$e"); done < <(expand_host_range "$item")
    fi
  done

  mapfile -t values < <(printf '%s\n' "${values[@]}" | dedupe)

  SAN_ARGS=(--san "$DOMAIN")
  for v in "${values[@]}"; do
    [[ "$v" != "$DOMAIN" ]] && SAN_ARGS+=(--san "$v")
  done
}

############################################
# Certificate issuance
############################################
issue_certificate() {
  local allow_overwrite="$1"

  ensure_certdir
  local crt="$(crt_path "$DOMAIN")"
  local csr="$(csr_path "$DOMAIN")"
  local key="$(key_path "$DOMAIN")"

  if [[ "$allow_overwrite" -eq 0 ]]; then
    [[ -f "$crt" || -f "$key" ]] && die "Files exist for '$DOMAIN' – use --renew"
  else
    rm -f "$csr"
  fi

  log_info "Generating CSR for '$DOMAIN'..."
  "$STEP" certificate create \
    "$DOMAIN" "$csr" "$key" \
    --csr --no-password --insecure \
    "${SAN_ARGS[@]}" \
    || die "CSR failed"

  log_info "Requesting token..."

  # ---------- BUILD TOKEN COMMAND ----------
  TOKEN_CMD=(
    "$STEP" ca token "$DOMAIN"
    "${SAN_ARGS[@]}"
    --ca-url="$CA_URL"
    --provisioner-password-file="$PROV_PW_FILE"
  )

  # Only add --not-after when explicitly enabled
  if [[ "$ENABLE_NOT_AFTER" == "true" ]]; then
    TOKEN_CMD+=(--not-after="$NOT_AFTER")
  fi
  # ------------------------------------------

  local token
  token="$("${TOKEN_CMD[@]}")" || die "Token failed"

  log_info "Signing certificate..."
  "$STEP" ca sign "$csr" "$crt" \
    --ca-url="$CA_URL" \
    --token "$token" \
    || die "Signing failed"

  chmod 600 "$key" "$crt" "$csr"
  log_ok "Issued: $DOMAIN"
  restart_npm
}

############################################
# Interactive mode
############################################
interactive_mode() {
  echo "=== Interactive Mode ==="
  read -rp "Common Name (CN): " input
  DOMAIN="$(normalize_domain "$input")"
  [[ -z "$DOMAIN" ]] && die "Domain required"

  read -rp "DNS SANs (comma-separated): " hosts
  read -rp "IP SANs (comma-separated): " ips

  SAN_INPUT=()
  IFS=',' read -ra arr <<<"$hosts,$ips"
  for i in "${arr[@]}"; do
    i="$(normalize_domain "$i")"
    [[ -n "$i" ]] && SAN_INPUT+=("$i")
  done

  read -rp "Restart NPM? (y/N): " ans
  [[ "${ans,,}" == "y" ]] && RELOAD_NPM=1
}

############################################
# CLI parsing
############################################
DOMAIN=""
SAN_INPUT=()
MODE="issue"
RENEW_DOMAIN=""
BULK_FILE=""
NON_INTERACTIVE=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    -d|--domain) DOMAIN="$2"; shift 2 ;;
    --domain=*) DOMAIN="${1#*=}"; shift ;;
    --san) SAN_INPUT+=("$(normalize_domain "$2")"); shift 2 ;;
    --san=*) SAN_INPUT+=("$(normalize_domain "${1#*=}")"); shift ;;
    --reload-npm) RELOAD_NPM=1; shift ;;
    --non-interactive) NON_INTERACTIVE=1; shift ;;
    --renew) MODE="renew-one"; RENEW_DOMAIN="$2"; shift 2 ;;
    --renew=*) MODE="renew-one"; RENEW_DOMAIN="${1#*=}"; shift ;;
    --renew-all) MODE="renew-all"; shift ;;
    --renew-days) RENEW_DAYS="$2"; shift 2 ;;
    --renew-days=*) RENEW_DAYS="${1#*=}"; shift ;;
    --bulk-wildcards) MODE="bulk-wildcards"; BULK_FILE="$2"; shift 2 ;;
    --bulk-wildcards=*) MODE="bulk-wildcards"; BULK_FILE="${1#*=}"; shift ;;
    -h|--help) echo "Usage: $(basename "$0") [options]"; exit 0 ;;
    *) die "Unknown argument: $1" ;;
  esac
done

############################################
# Execute mode
############################################
case "$MODE" in
  issue)
    [[ -z "$DOMAIN" && "$NON_INTERACTIVE" -eq 1 ]] && die "Domain required"
    [[ -z "$DOMAIN" ]] && interactive_mode
    build_san_args
    issue_certificate 0
    ;;
esac
